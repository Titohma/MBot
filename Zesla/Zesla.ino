// generated by mBlock5 for mBot Ranger
// codes make you happy

#include <Arduino.h>
#include <Wire.h>
#include <SoftwareSerial.h>
#include <MeAuriga.h>

int GAUCHE_NOIR_DROIT_NOIR = 0;
int GAUCHE_NOIR_DROIT_BLANC = 1;
int GAUCHE_BLANC_DROIT_NOIR = 2;
int GAUCHE_BLANC_DROIT_BLANC = 3;

int TOUT_DROIT = 1;
int GAUCHE = 3;
int DROITE = 4;
int MARCHE_ARRIERE = 2;

float vitesse;
int dernierInstantCalculVitesse;
int nombreScanVolumeSonore;
int moyenneVolumeSonore;
int distance;

MeLightSensor lightsensor_12(12);
MeLineFollower capteurLigne(9);
MeSoundSensor capteurSon(14);
MeEncoderOnBoard Encoder_1(SLOT1);
MeEncoderOnBoard Encoder_2(SLOT2);
MeUltrasonicSensor capteurObstacle(10);
MeBuzzer buzzer;
MeRGBLed led(0, 12);

void debug(String message) {
  Serial.print(message);
  Serial.print("\n");
}

void isr_process_encoder1(void)
{
  if(digitalRead(Encoder_1.getPortB()) == 0){
    Encoder_1.pulsePosMinus();
  }else{
    Encoder_1.pulsePosPlus();
  }
}
void isr_process_encoder2(void)
{
  if(digitalRead(Encoder_2.getPortB()) == 0){
    Encoder_2.pulsePosMinus();
  }else{
    Encoder_2.pulsePosPlus();
  }
}
void se_deplacer(int direction, int speed)
{
  int leftSpeed = 0;
  int rightSpeed = 0;
  if(direction == TOUT_DROIT){
    leftSpeed = -speed;
    rightSpeed = speed;
  }else if(direction == MARCHE_ARRIERE){
    leftSpeed = speed;
    rightSpeed = -speed;
  }else if(direction == GAUCHE){
    leftSpeed = -speed;
    rightSpeed = -speed;
  }else if(direction == DROITE){
    leftSpeed = speed;
    rightSpeed = speed;
  }
  Encoder_1.setTarPWM(leftSpeed);
  Encoder_2.setTarPWM(rightSpeed);
}

void _delay(float seconds) {
  if(seconds < 0.0){
    seconds = 0.0;
  }
  long endTime = millis() + seconds * 1000;
  while(millis() < endTime) delay(10);
}

int etat_de_la_ligne() {
  return capteurLigne.readSensors();
}

int recuperer_volume_sonore() {
  return capteurSon.strength();
}

int recuperer_distance() {
  return capteurObstacle.distanceCm();
}

void colorer_leds(int rouge, int vert, int bleu) {
    led.setColor(0, rouge, vert, bleu);
    led.setColor(1, rouge, vert, bleu);
    led.setColor(2, rouge, vert, bleu);
    led.setColor(3, rouge, vert, bleu);
    led.setColor(4, rouge, vert, bleu);
    led.setColor(5, rouge, vert, bleu);
    led.setColor(6, rouge, vert, bleu);
    led.setColor(7, rouge, vert, bleu);
    led.setColor(8, rouge, vert, bleu);
    led.setColor(9, rouge, vert, bleu);
    led.setColor(10, rouge, vert, bleu);
    led.setColor(11, rouge, vert, bleu);
    led.show();
}

void calculer_vitesse() {
  //buzzer.tone(0, );
  
  if(millis() - dernierInstantCalculVitesse > 3000) {
    debug(String(moyenneVolumeSonore));
    
    if(moyenneVolumeSonore > 400) {
      vitesse = 255;
    } else if(moyenneVolumeSonore > 250) {
      vitesse = 200;
    } else {
      vitesse = 150;
    }
    debug(String(vitesse));
    dernierInstantCalculVitesse = millis();
    moyenneVolumeSonore = recuperer_volume_sonore();
    nombreScanVolumeSonore = 0;
  } else {
    nombreScanVolumeSonore++;
    float a = 1.0 / nombreScanVolumeSonore;
    float b = 1.0 - a;
    moyenneVolumeSonore = a * recuperer_volume_sonore() + b * moyenneVolumeSonore;
  }

  distance = recuperer_distance();
  debug("Distance");
  debug(String(distance));
  if(distance < 10){
    vitesse = 0;
    // Allumer le klaxon
    buzzer.tone(500, 1000);
  } else if (distance < 20) {
    vitesse = 150;
    // Allumer les phares
    colorer_leds(255, 255, 255);
  } else {
    // L'obstacle est trop loin. Il n'y a plus de risque !
    colorer_leds(0, 0, 0);
  }
}

void setup() {
  Serial.begin(115200);
  Encoder_1.reset(SLOT1);
  Encoder_2.reset(SLOT2);

  buzzer.setpin(45);
  led.setpin(44);
  led.fillPixelsBak(0, 2, 1);

  //Set PWM 8KHz
  TCCR1A = _BV(WGM10);
  TCCR1B = _BV(CS11) | _BV(WGM12);
  TCCR2A = _BV(WGM21) | _BV(WGM20);
  TCCR2B = _BV(CS21);
  
  // these interrupts are necesssary to
  // enable the motor to know where it is
  //attachInterrupt(Encoder_1.getIntNum(), isr_process_encoder1, RISING);
  //attachInterrupt(Encoder_2.getIntNum(), isr_process_encoder2, RISING);

  dernierInstantCalculVitesse = millis();
  nombreScanVolumeSonore = 0;
  moyenneVolumeSonore = recuperer_volume_sonore();
}

void loop() {
  calculer_vitesse();
  if(etat_de_la_ligne() == GAUCHE_BLANC_DROIT_BLANC){
    //debug("[Gauche] BLANC / [Droit] BLANC");
    //debug("Direction : Tout droit");
    se_deplacer(TOUT_DROIT, vitesse);
  }else{
    if(etat_de_la_ligne() == GAUCHE_NOIR_DROIT_BLANC){
      //debug("[Gauche] NOIR / [Droit] BLANC");
      //debug("Direction : A droite");
      se_deplacer(DROITE, vitesse);
    }else{
      if(etat_de_la_ligne() == GAUCHE_BLANC_DROIT_NOIR){
        //debug("[Gauche] BLANC / [Droit] NOIR");
        //debug("Direction : A gauche");
        se_deplacer(GAUCHE, vitesse);
      }else{
        //debug("[Gauche] NOIR / [Droit] NOIR");
        //debug("Direction : On s arrete");
        //Encoder_1.setTarPWM(0);
        //Encoder_2.setTarPWM(0);
        se_deplacer(MARCHE_ARRIERE, vitesse);
        colorer_leds(255, 0, 0);
      }
    }
  }
  Encoder_1.loop();
  Encoder_2.loop();
}
